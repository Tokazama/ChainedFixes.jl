var documenterSearchIndex = {"docs":
[{"location":"#ChainedFixes","page":"ChainedFixes","title":"ChainedFixes","text":"","category":"section"},{"location":"","page":"ChainedFixes","title":"ChainedFixes","text":"Modules = [ChainedFixes]","category":"page"},{"location":"#ChainedFixes.ChainedFixes","page":"ChainedFixes","title":"ChainedFixes.ChainedFixes","text":"ChainedFixes\n\n(Image: Build Status) (Image: codecov) (Image: stable-docs) (Image: dev-docs)\n\nChainedFixes.jl provides useful tools for interacting with functions where arguments are fixed to them.\n\nThe or, and methods\n\nSome simple functionality available form this package is chaining any fixed function.\n\njulia> using ChainedFixes\n\njulia> gt_or_lt = or(>(10), <(5))\nor(>(10), <(5))\n\njulia> gt_or_lt(2)\ntrue\n\njulia> gt_or_lt(6)\nfalse\n\njulia> gt_and_lt = and(>(1), <(5))\nand(>(1), <(5))\n\njulia> gt_and_lt(2)\ntrue\n\njulia> gt_and_lt(0)\nfalse\n\nThere's more convenient syntax for these available in the Julia REPL.\n\njulia> gt_or_lt = >(10) ⩔ <(5); # \\Or<TAB>\n\njulia> gt_or_lt(2)\ntrue\n\njulia> gt_or_lt(6)\nfalse\n\njulia> gt_and_lt = >(1) ⩓ <(5); # \\And<TAB>\n\njulia> gt_and_lt(2)\ntrue\n\njulia> gt_and_lt(0)\nfalse\n\nCreating new fixed methods with @nfix\n\nAny function can have methods fixed to it with @nfix.\n\njulia> fxn1(x::Integer, y::AbstractFloat, z::AbstractString) = Val(1);\n\njulia> fxn1(x::Integer, y::AbstractString, z::AbstractFloat) = Val(2);\n\njulia> fxn1(x::AbstractFloat, y::Integer, z::AbstractString) = Val(3);\n\njulia> fxn2(; x, y, z) = fxn1(x, y, z);\n\njulia> fxn3(args...; kwargs...) = (fxn1(args...), fxn2(; kwargs...));\n\njulia> f = @nfix fxn1(1, 2.0, _)\nfxn1(1, 2.0, _1)\n\njulia> f(\"a\")\nVal{1}()\n\njulia> f = @nfix fxn1(1, _, 2.0)\nfxn1(1, _1, 2.0)\n\njulia> f(\"a\")\nVal{2}()\n\njulia> f = @nfix fxn1(1.0, _, \"\")\nfxn1(1.0, _1, \"\")\n\njulia> f(2)\nVal{3}()\n\njulia> f = @nfix fxn2(x=1, y=2.0)\nfxn2(; x = 1, y = 2.0)\n\njulia> f(z = \"a\")\nVal{1}()\n\njulia> f = @nfix fxn2(x=1, z=2.0)\nfxn2(; x = 1, z = 2.0)\n\njulia> f(y = \"a\")\nVal{2}()\n\njulia> f = @nfix fxn3(1, 2.0, _; x = 1.0, z= \"\")\nfxn3(1, 2.0, _1; x = 1.0, z = \"\")\n\njulia> f(\"\"; y = 1)\n(Val{1}(), Val{3}())\n\n\nIf we specify the underscore suffix we arguments can be repeated within a single function.\n\njulia> f = @nfix *(_1, _1)\n*(_1, _1)\n\njulia> f(2)\n4\n\n\nChaining piped methods\n\nWe can create a chain a functions that act like an uncalled pipe (e.g., |>). A chain of fixed functions can be chained together via pipe_chain.\n\njulia> f = pipe_chain(@nfix(_ * \"is \"), @nfix(_ * \"a \"), @nfix(_ * \"sentence.\"))\n|> *(_1, \"is \") |> *(_1, \"a \") |> *(_1, \"sentence.\")\n\njulia> f(\"This \")\n\"This is a sentence.\"\n\njulia> f2 = pipe_chain(f, endswith(\"sentence.\"))\n|> *(_1, \"is \") |> *(_1, \"a \") |> *(_1, \"sentence.\") |> endswith(\"sentence.\")\n\njulia> f2(\"This \")\ntrue\n\njulia> f2 = pipe_chain(f, startswith(\"This\"))\n|> *(_1, \"is \") |> *(_1, \"a \") |> *(_1, \"sentence.\") |> startswith(\"This\")\n\njulia> f2(\"This \")\ntrue\n\njulia> f = pipe_chain(and(<=(3), !=(2)), ==(true), in(trues(2)), !in(falses(2)), >=(true))\n|> and(<=(3), !=(2)) |> ==(true) |> in(Bool[1, 1]) |> !in(Bool[0, 0]) |> >=(true)\n\njulia> f(1)\ntrue\n\njulia> f = pipe_chain(isapprox(0.1), !isapprox(0.2))\n|> ≈(0.1) |> !≈(0.2)\n\njulia> f(0.1 - 1e-10)\ntrue\n\n\nInternally, this includes support for those found in Julia's Base module (Base.Fix1, Base.Fix2) and from ChainedFixes (ChainedFix and NFix).\n\nConstants\n\nThe constants on the right sight of the following table may be exported and accessed via using ChainedFixes.ChainedCore The syntax corresponding to each constant is on the left.\n\nSyntax Type Constant\npipe_chain(f1, f2) PipeChain{F1,F2}\nand(f1::F1, f1::F2)/⩓(f1::F1, f1::F2) And{F1,F2}\nor(f1::F1, f1::F2)/⩔(f1::F1, f1::F2) Or{F1,F2}\nisapprox(x::T; kwargs::Kwargs) Approx{T,Kwargs}\n!isapprox(x::T; kwargs::Kwargs) NotApprox{T,Kwargs}\nin(x::T) In{T}\n!in(x::T) NotIn{T}\n<(x::T) Less{T}\n<=(x::T) LessThanOrEqual{T}\n>(x::T) Greater{T}\n>=(x::T) GreaterThanOrEqual{T}\n==(x::T) Equal{T}\nisequal(x::T) Equal{T}\n!=(x::T) NotEqual{T}\nstartswith(x::T) StartsWith{T}\nendswith(x::T) EndsWith{T}\n\nCombining fixed methods\n\nThe real utility of ChainedFixes is when combining fixed methods in creative ways\n\njulia> splat_pipe(op, args::Tuple) = op(args...);\n\njulia> splat_pipe(op) = @nfix splat_pipe(op, _...);\n\njulia> f = pipe_chain(extrema, splat_pipe(+))\n|> extrema |> splat_pipe(+, _...)\n\njulia> f([1 2; 3 4])\n5\n\n\n\n\n\n\n","category":"module"}]
}
