var documenterSearchIndex = {"docs":
[{"location":"#ChainedFixes-1","page":"ChainedFixes","title":"ChainedFixes","text":"","category":"section"},{"location":"#","page":"ChainedFixes","title":"ChainedFixes","text":"Modules = [ChainedFixes]","category":"page"},{"location":"#ChainedFixes.ChainedFixes","page":"ChainedFixes","title":"ChainedFixes.ChainedFixes","text":"ChainedFixes\n\n(Image: Build Status) (Image: codecov) (Image: stable-docs) (Image: dev-docs)\n\nChainedFixes.jl provides useful tools for interacting with functions where arguments are fixed to them. This includes support for those found in Julia's Base module (Base.Fix1, Base.Fix2) and exported from ChainedFixes (ChainedFix and NFix).\n\nSome simple functionality available form this package is chaining any fixed function.\n\njulia> using ChainedFixes\n\njulia> gt_or_lt = or(>(10), <(5));\n\njulia> gt_or_lt(2)\ntrue\n\njulia> gt_or_lt(6)\nfalse\n\n\njulia> gt_and_lt = and(>(1), <(5));\n\njulia> gt_and_lt(2)\ntrue\n\njulia> gt_and_lt(0)\nfalse\n\nThere's more convenient syntax for these available in the Julia REPL.\n\njulia> gt_or_lt = >(10) ⩔ <(5); # \\Or<TAB>\n\njulia> gt_or_lt(2)\ntrue\n\njulia> gt_or_lt(6)\nfalse\n\n\njulia> gt_and_lt = >(1) ⩓ <(5); # \\And<TAB>\n\njulia> gt_and_lt(2)\ntrue\n\njulia> gt_and_lt(0)\nfalse\n\nAny function can have methods fixed to it with the NFix function.\n\njulia> fxn1(x::Integer, y::AbstractFloat, z::AbstractString) = Val(1);\n\njulia> fxn1(x::Integer, y::AbstractString, z::AbstractFloat) = Val(2);\n\njulia> fxn1(x::AbstractFloat, y::Integer, z::AbstractString) = Val(3);\n\njulia> fxn2(; x, y, z) = fxn1(x, y, z);\n\njulia> fxn3(args...; kwargs...) = (fxn1(args...), fxn2(; kwargs...));\n\njulia> NFix{(1,2)}(fxn1, 1, 2.0)(\"a\")\nVal{1}()\n\njulia> NFix{(1,3)}(fxn1, 1, 2.0)(\"a\")\nVal{2}()\n\njulia> NFix{(1,3)}(fxn1, 1.0, \"\")(2)\nVal{3}()\n\njulia> NFix(fxn2, x=1, y=2.0)(z = \"a\")\nVal{1}()\n\njulia> NFix(fxn2, x=1, z=2.0)(y=\"a\")\nVal{2}()\n\njulia> NFix{(1,2)}(fxn3, 1, 2.0; x=1.0, z=\"\")(\"\"; y = 1)\n(Val{1}(), Val{3}())\n\n\nConstants\n\nThe following constants are exported.\n\nSyntax Type Constant\nand(f1::F1, f1::F2)/⩓(f1::F1, f1::F2) And{F1,F2}\nor(f1::F1, f1::F2)/⩔(f1::F1, f1::F2) Or{F1,F2}\nisapprox(x::T; kwargs::Kwargs) Approx{T,Kwargs}\n!isapprox(x::T; kwargs::Kwargs) NotApprox{T,Kwargs}\nin(x::T) In{T}\n!in(x::T) NotIn{T}\n<(x::T) Less{T}\n<=(x::T) LessThanOrEqual{T}\n>(x::T) Greater{T}\n>=(x::T) GreaterThanOrEqual{T}\n==(x::T) Equal{T}\nisequal(x::T) Equal{T}\n!=(x::T) NotEqual{T}\nstartswith(x::T) StartsWith{T}\nendswith(x::T) EndsWith{T}\n\n\n\n\n\n","category":"module"},{"location":"#ChainedFixes.and-Tuple{Any,Any}","page":"ChainedFixes","title":"ChainedFixes.and","text":"and(x, y)\n\nSynonymous with bitwise & operator but may be used to chain multiple Fix1 or Fix2 operations. The ⩓ (\\And<TAB>) operator may be used in its place (e.g., x ⩓ y).\n\nExamples\n\njulia> using ChainedFixes\n\njulia> and(true, <(5))(1)\ntrue\n\njulia> and(<(5), false)(1)\nfalse\n\njulia> and(and(<(5), >(1)), >(2))(3)\ntrue\n\njulia> and(<(5) ⩓ >(1), >(2))(3)  # ⩓ == \\And\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"#ChainedFixes.execute-Tuple{Any,Vararg{Any,N} where N}","page":"ChainedFixes","title":"ChainedFixes.execute","text":"execute(f, args...; kwargs...) -> f(args...; kwargs...)\n\nExecutes function f with provided positional arugments (args...) and keyword arguments (kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"#ChainedFixes.getargs-Tuple{Any}","page":"ChainedFixes","title":"ChainedFixes.getargs","text":"getargs(f) -> Tuple\n\nReturn a tuple of fixed positional arguments of the fixed function f.\n\nExamples\n\njulia> using ChainedFixes\n\njulia> getargs(==(1))\n(1,)\n\n\n\n\n\n\n","category":"method"},{"location":"#ChainedFixes.getfxn-Tuple{Any}","page":"ChainedFixes","title":"ChainedFixes.getfxn","text":"getfxn(f) -> Function\n\nGiven a fixed function f, returns raw method without any fixed arguments.\n\n\n\n\n\n","category":"method"},{"location":"#ChainedFixes.getkwargs-Tuple{Any}","page":"ChainedFixes","title":"ChainedFixes.getkwargs","text":"getkwargs(f) -> Pairs\n\nReturn the fixed keyword arguments of the fixed function f.\n\nExamples\n\njulia> using ChainedFixes\n\njulia> getkwargs(isapprox(1, atol=2))\npairs(::NamedTuple) with 1 entry:\n  :atol => 2\n\n\n\n\n\n\n","category":"method"},{"location":"#ChainedFixes.is_fixed_function-Union{Tuple{T}, Tuple{T}} where T","page":"ChainedFixes","title":"ChainedFixes.is_fixed_function","text":"is_fixed_function(f) -> Bool\n\nReturns true if f is a callable function that already has arguments fixed to it. A \"fixed\" function can only be called on one argument (e.g., f(arg)) and all other arguments are already assigned. Functions that return true should also have getargs defined.\n\n\n\n\n\n","category":"method"},{"location":"#ChainedFixes.or-Tuple{Any,Any}","page":"ChainedFixes","title":"ChainedFixes.or","text":"or(x, y)\n\nSynonymous with bitwise | operator but may be used to chain multiple Fix1 or Fix2 operations. The ⩔ (\\Or<TAB>) operator may be used in its place (e.g., x ⩔ y).\n\nExamples\n\njulia> using ChainedFixes\n\njulia> or(true, <(5))(1)\ntrue\n\njulia> or(<(5), false)(1)\ntrue\n\njulia> or(<(5) ⩔ >(1), >(2))(3)  # ⩔ == \\Or\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#ChainedFixes.positions-Tuple{Any}","page":"ChainedFixes","title":"ChainedFixes.positions","text":"positions(f) -> Tuple{Vararg{Int}}\n\nReturns positions of new argument calls to f. For example, Fix2 would return (2,)\n\n\n\n\n\n","category":"method"}]
}
